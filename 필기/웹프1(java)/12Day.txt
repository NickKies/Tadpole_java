필드의 구분

클래스의 필드는 클래스에 포함된 변수를 의미합니다. 클래스의 포함된 변수는 총 3가지로 구분됩니다.

- 클래스 변수 : staic이 붙어있는 변수. 초기화를 하지 않아도 변수의 타입에 맞게 자동으로 초기화가 됩니다. 해당 클래스의 모든 인스턴스가 공유해야 하는 값을 유지하기 위해 사용됩니다.
- 인스턴스 변수 : 클래스 영역에 위치한 변수 중 static이 붙지 않은 변수. 초기화를 하지 않아도 변수의 타입에 맞게 자동으로 초기화가 됩니다. 인스턴스마다 가져야 하는 고유한 값을 유지하기 위해 사용됩니다.
- 지역 변수 : 메소드나 생성자, 초기화 블록 내에 위치한 변수. 사용하기 전에 초기화를 하지 않으면, 자바 컴파일 에러가 발생됩니다.

변수타입			초기값
char			'\u0000'
byte, short, int	0
long			0L
float			0.0F
double			0.0 또는 0.0D
boolean			false;
배열, 인스턴스		null


class Sample {
	static int num1; // 클래스 변수
	String str1; // 인스턴스 변수

	void method1(){
		int num2=10; // 지역 변수 
	}
}


메소드의 구분
클래스의 메소드란 어떠한 작업을 수행하기 위한 명령문의 집합이라고 할 수 있습니다. static키워드의 여부에 따라 클래스 메소드, 인스턴스 메소드로 나뉩니다.

- 클래스 메소드 : static 키워드를 가지는 메소드. 클래스 변수와 마찬가지로 인스턴스를 생성하지 않고도 바로 사용할 수 있습니다. 따라서 클래스 메소드는 메소드 내부에서 인스턴스 변수를 사용할 수 없습니다.

- 인스턴스 메소드 : static 키워드를 가지지 않는 메소드.

class Sample {
	String str1; // 인스턴스 변수

	void method1(){	// 인스턴스 메소드

	}

	static void method2(){	// 클래스 메소드
		
	}
}


필드의 초기화
자바에서는 필드를 초기화하지 않아도 변수의 타입에 맞는 초깃값으로 자동으로 초기화가 됩니다. 지역 변수와 마찬가지로 적절한 값으로 초기화한 후에 사용하는 것을 권장합니다. 필드는 지역 변수와 다르게 여러가지 방법으로 초기화를 할 수 있습니다.

1.
class Sample {
	static int var1 = 0;
	int var2 = 10;
}

2. 
class Sample {
	int var1;
	int var2;

	Sample(){
		this.var1 = 0;
		this.var2 = 10;
	}
}

3. 
class Sample {
	int var1;
	int var2;
	{
		this.var1 = 0;
		this.var2 = 10;
	}
}

class Sample {
	int var1;
	static int var2;

	static {
		var2 = 10;
	}
}


상속

상속이란 특정 클래스를 구성할 때 기존 클래스의 데이터와 메소드를 부모 클래스에서 그대로 물려받아 중복적인 코드를 줄이는 것과, 하나의 변수 타입으로 여러 종류의 객체를 의미하는 추상화된 방식의 프로그램이 가능하게 하는 객체지향 기법입니다. JAVA에서는 C++과 달리 하나의 부모 클래스만 가질 수 있습니다.

class 게시판 {	// 상위클래스, 기초클래스, 부모클래스
	글쓰기;
	글목록;
	글보기;
}

class 업그레이드게시판 extends 게시판 {	// 하위클래스, 파생클래스, 자식클래스
	[글쓰기]->[첨부파일업로드글쓰기]
	[글목록]
	[글보기]
}

상속을 사용하게 되면?
1. 기존에 작성된 클래스를 재활용 할 수 있습니다.
2. 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 됩니다.
3. 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련합니다.

문법

class 자식클래스이름 extends 부모클래스이름

자식 클래스에는 부모 클래스의 필드와 메소드만이 상속되며, 생성자와 초기화 블록은 상속되지 않습니다.
또한 부모 클래스의 접근제어가 private , default 로 설정된 멤버는 자식 클래스에서 상속 받지만 접근할 수는 없습니다.

메소드 오버라이딩(method overriding)
서로 다른 시그니처를 갖는 여러 메소드를 하나의 이름으로 정의하는 것은 오버로딩(overloading)입니다. 오버라이딩이란(overriding)이란 상속관계에 있는 부모클래스에서 이미 정의된 메소드를 자식클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것입니다.


super와 super()

super 키워드는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수입니다. 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super키워드를 사용하여 구별할 수 있습니다. super 참조변수를 사용할 수 있는 대상은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없습니다.

super() 메소드는 부모 클래스의 생성자를 호출할 때 사용됩니다. 자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 멤버뿐만 아니라 부모 클래스의 모든 멤버까지도 포함되어 있습니다. 따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야만 합니다. 이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 Object클래스의 생성자까지 계속 거슬러 올라가며 수행됩니다.

